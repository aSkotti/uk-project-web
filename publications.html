<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Engineering of Data Analysis Pipelines - Publications</title>
    
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.0/css/bootstrap.min.css" rel="stylesheet">
    <link href="styles.css" rel="stylesheet">
</head>

<body>
    <nav class="navbar navbar-expand-lg navbar-light fixed-top">
        <div class="container">
            <a class="navbar-brand" href="index.html">
                <span style="font-weight: 600; color: var(--primary-red); font-size: 1.5rem;">Ch-RiGiD</span>
            </a>
            
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
            
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item">
                        <a class="nav-link" href="index.html">Home</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="people.html">People</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link active" href="publications.html">Publications</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="software.html">Software</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="contact.html">Contact</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <div class="page-content">
        <div class="content-section">
            <div class="container">
                <h2 class="section-header" id="publications">Publications</h2>
                
                <div class="row">
                    <div class="col-lg-12">
                        <h3 class="publication-year-header">2026</h3>
                        <div class="publication-item">
                            <div class="publication-links">
                                <a href="https://arxiv.org/abs/2602.00033" target="_blank" class="pub-link">Link</a>
                                <a href="https://doi.org/10.48550/arXiv.2602.00033" target="_blank" class="pub-link secondary">DOI</a>
                                <button class="pub-link secondary" onclick="showBibtex('bibtex_new6')">BibTeX</button>
                            </div>
                            <div class="publication-title">Mapping the Stochastic Penal Colony</div>
                            <div class="publication-authors">R. Grimm</div>
                            <div class="publication-venue">arXiv preprint, 2026</div>
                            <div id="abstract_new6" class="publication-abstract">
                                <p class="abstract-text">With peak content moderation seemingly behind us, this paper revisits its punitive side. But instead of focusing on who is being (disproportionately) moderated, it focuses on the punishment itself and makes three contributions. First, it develops a novel methodology that combines auto-ethnography for collecting experiences and artifacts with procedural justice for analyzing them. Second, it reworks Foucault's model of the penal system for the algorithmic age, restoring the penal colony as the historically liminal practice between punishment as performance and punishment as discipline, i.e., the stochastic penal colony. Finally, it applies this methodological and conceptual framing to three case studies, one on the gallingly performative moderation by pre-Musk Twitter, one on the exhaustively punitive content moderation for OpenAI's DALLE~2, and one on the relatively light touch but still rather precious moderation by Pinterest. While substantially different, all three feature the pervasive threat of account suspension, thereby banishing users to the stochastic penal colony.</p>
                            </div>
                            <div id="bibtex_new6" class="bibtex-content" style="display: none;">
                                <pre>@misc{grimm2026mappingstochasticpenalcolony,
    title = {{Mapping the Stochastic Penal Colony}},
    author = {Grimm, Robert},
    year = {2026},
    eprint = {2602.00033},
    archivePrefix = {arXiv},
    primaryClass = {cs.CY},
    doi = {10.48550/arXiv.2602.00033},
    url = {https://arxiv.org/abs/2602.00033},
}</pre>
                            </div>
                        </div>
                        
                        <h3 class="publication-year-header">2025</h3>
                        <div class="publication-item">
                            <div class="publication-links">
                                <a href="https://doi.org/10.1145/3746059.3747646" target="_blank" class="pub-link">Link</a>
                                <a href="https://doi.org/10.1145/3746059.3747646" target="_blank" class="pub-link secondary">DOI</a>
                                <button class="pub-link secondary" onclick="showBibtex('bibtex_new1')">BibTeX</button>
                            </div>
                            <div class="publication-title">Denicek: Computational Substrate for Document-Oriented End-User Programming</div>
                            <div class="publication-authors">T. Petříček, J. Edwards</div>
                            <div class="publication-venue">Proceedings of the 38th Annual ACM Symposium on User Interface Software and Technology, 2025</div>
                            <div id="abstract_new1" class="publication-abstract">
                                <p class="abstract-text">User-centric programming research gave rise to a variety of compelling programming experiences, including collaborative source code editing, programming by demonstration, incremental recomputation, schema change control, end-user debugging and concrete programming. Those experiences advance the state of the art of end-user programming, but they are hard to implement on the basis of established programming languages and system.
                                    We contribute Denicek, a computational substrate that simplifies the implementation of the above programming experiences. Denicek represents a program as a series of edits that construct and transform a document consisting of data and formulas. Denicek provides three operations on edit histories: edit application, merging of histories and conflict resolution. Many programming experiences can be easily implemented by composing these three operations.
                                    We present the architecture of Denicek, discuss key design considerations and elaborate the implementation of a variety of programming experiences. To evaluate the proposed substrate, we use Denicek to develop an innovative interactive data science notebook system. The case study shows that the Denicek computational substrate provides a suitable basis for the design of rich, interactive end-user programming systems.</p>
                            </div>
                            <div id="bibtex_new1" class="bibtex-content" style="display: none;">
                                <pre>@inproceedings{petricek_denicek_2025,
    title = {{Denicek: Computational Substrate for Document-Oriented End-User Programming}},
    author = {Petricek, Tomas and Edwards, Jonathan},
    year = {2025},
    booktitle = {{Proceedings of the 38th Annual ACM Symposium on User Interface Software and Technology}},
    publisher = {Association for Computing Machinery},
    series = {{UIST '25}},
    location = {New York, NY, USA},
    doi = {10.1145/3746059.3747646},
    isbn = {979-8-4007-2037-6},
    pages = {1--19},
    url = {https://doi.org/10.1145/3746059.3747646},
    shorttitle = {Denicek},
}</pre>
                            </div>
                        </div>
                        
                        <div class="publication-item">
                            <div class="publication-links">
                                <a href="https://doi.org/10.1145/3759429.3762633" target="_blank" class="pub-link">Link</a>
                                <a href="https://doi.org/10.1145/3759429.3762633" target="_blank" class="pub-link secondary">DOI</a>
                                <button class="pub-link secondary" onclick="showBibtex('bibtex_new2')">BibTeX</button>
                            </div>
                            <div class="publication-title">The Unix Executable as a Smalltalk Method: And Its Implications for Unix-Smalltalk Unification</div>
                            <div class="publication-authors">J. Jakubovic</div>
                            <div class="publication-venue">2025 ACM SIGPLAN International Symposium on New Ideas, New Paradigms, and Reflections on Programming and Software (Onward! 2025), 2025</div>
                            <div id="abstract_new2" class="publication-abstract">
                                <p class="abstract-text">Unix and Smalltalk are very different in the details, but bear curious similarities in their broad outlines. Prior work has made these comparisons at a high level and sketched a path for retrofitting Smalltalk's advantages onto Unix (without compromising the advantages of the latter). Everybody seems to agree on identifying the Unix file with the Smalltalk object, but this still leaves much unspecified. I argue that we should identify the Unix executable with the Smalltalk method. A Smalltalk VM implementation via the filesystem falls out quite easily from this premise; however, the severe overhead associated with Unix processes casts doubt on its practical realisation. Nevertheless, we can see several ways around this problem. The connection shows promise for realising the benefits of Smalltalk within Unix without sequestering the former in a hermetically sealed image and VM.</p>
                            </div>
                            <div id="bibtex_new2" class="bibtex-content" style="display: none;">
                                <pre> @inproceedings{jakubovic_unix_2025,
    title = {{The Unix Executable as a Smalltalk Method: And Its Implications for Unix-Smalltalk Unification}},
    author = {Jakubovic, Joel},
    year = {2025},
    booktitle = {{Proceedings of the 2025 ACM SIGPLAN International Symposium on New Ideas, New Paradigms, and Reflections on Programming and Software}},
    publisher = {Association for Computing Machinery},
    series = {{Onward! '25}},
    location = {New York, NY, USA},
    doi = {10.1145/3759429.3762633},
    isbn = {979-8-4007-2151-9},
    pages = {227--242},
    url = {https://dl.acm.org/doi/10.1145/3759429.3762633},
    shorttitle = {The Unix Executable as a Smalltalk Method},
}</pre>
                            </div>
                        </div>
                        
                        <div class="publication-item">
                            <div class="publication-links">
                                <a href="https://drops.dagstuhl.de/entities/document/10.4230/OASIcs.Programming.2025.1" target="_blank" class="pub-link">Link</a>
                                <a href="https://doi.org/10.4230/OASIcs.Programming.2025.1" target="_blank" class="pub-link secondary">DOI</a>
                                <button class="pub-link secondary" onclick="showBibtex('bibtex1')">BibTeX</button>
                            </div>
                            <div class="publication-title">Comparing R Bytecode Compilers Written in R, Java, and Rust</div>
                            <div class="publication-authors">P. Donat-Bouillud, F. Křikava, J. Hain, A. Plodek, J. Vitek</div>
                            <div class="publication-venue">Companion Proceedings of the 9th International Conference on the Art, Science, and Engineering of Programming (Programming 2025), pp. 1:1–1:6, 2025</div>
                            <div id="abstract1" class="publication-abstract">
                                <p class="abstract-text">This paper presents a comparative analysis of three implementations of the R bytecode compiler: the official R implementation, a Java-based compiler, and a Rust-based compiler. The R compiler, written in R itself, poses challenges in terms of performance and maintainability. We evaluate designs of the compilers, their trade-offs, and performance characteristics. The Rust version outperforms the Java version, which itself outperforms the R version.</p>
                            </div>
                            <div id="bibtex1" class="bibtex-content" style="display: none;">
                                <pre>@inproceedings{donatbouillud_comparing_2025,
    title = {{Comparing R Bytecode Compilers Written in R, Java, and Rust}},
    author = {Donat-Bouillud, Pierre and Křikava, Filip and Hain, Jakob and Plodek, Adam and Vitek, Jan},
    year = {2025},
    booktitle = {{Companion Proceedings of the 9th International Conference on the Art, Science, and Engineering of Programming (Programming 2025)}},
    editor = {Edwards, Jonathan and Perera, Roly and Petricek, Tomas},
    publisher = {Schloss Dagstuhl -- Leibniz-Zentrum für Informatik},
    series = {{Open Access Series in Informatics (OASIcs)}},
    location = {Dagstuhl, Germany},
    doi = {10.4230/OASIcs.Programming.2025.1},
    isbn = {978-3-95977-382-9},
    pages = {1:1--1:6},
    url = {https://drops.dagstuhl.de/entities/document/10.4230/OASIcs.Programming.2025.1},
    volume = {134},
}</pre>
                            </div>
                        </div>
                        
                        <div class="publication-item">
                            <div class="publication-links">
                                <a href="https://doi.org/10.1145/3759548.3763370" target="_blank" class="pub-link">Link</a>
                                <a href="https://doi.org/10.1145/3759548.3763370" target="_blank" class="pub-link secondary">DOI</a>
                                <button class="pub-link secondary" onclick="showBibtex('bibtex2')">BibTeX</button>
                            </div>
                            <div class="publication-title">Copy-and-Patch Just-in-Time Compiler for R</div>
                            <div class="publication-authors">M. Kocourek, F. Křikava, J. Vitek</div>
                            <div class="publication-venue">Proceedings of the 17th ACM SIGPLAN International Workshop on Virtual Machines and Intermediate Languages, pp. 12–21, 2025</div>
                            <div id="abstract2" class="publication-abstract">
                                <p class="abstract-text">Copy-and-patch is a technique for building baseline just-in-time compilers from existing interpreters. It has been successfully applied to languages such as Lua and Python. This paper reports on our experience using this technique to implement a compiler for the R programming language. We describe how this new compiler integrates with the GNU R virtual machine, present the key optimizations we implemented, and evaluate the feasibility of this approach for R. Copy-and-patch also allows extensions such as integration of the feedback recording required by multi-tier compilation. Our evaluation on 57 programs demonstrates very fast compilation times (980 bytecode instructions per millisecond), reasonable performance gains (1.15x–1.91x speedup over GNU R), and manageable implementation complexity.</p>
                            </div>
                            <div id="bibtex2" class="bibtex-content" style="display: none;">
                                <pre>@inproceedings{kocourek_copyandpatch_2025,
    title = {{Copy-and-Patch Just-in-Time Compiler for R}},
    author = {Kocourek, Matěj and Křikava, Filip and Vitek, Jan},
    year = {2025},
    booktitle = {{Proceedings of the 17th ACM SIGPLAN International Workshop on Virtual Machines and Intermediate Languages}},
    publisher = {Association for Computing Machinery},
    series = {{VMIL '25}},
    location = {New York, NY, USA},
    doi = {10.1145/3759548.3763370},
    isbn = {979-8-4007-2164-9},
    pages = {12--21},
    url = {https://doi.org/10.1145/3759548.3763370},
}</pre>
                            </div>
                        </div>
                        
                        <div class="publication-item">
                            <div class="publication-links">
                                <a href="https://doi.org/10.1145/3736731.3746156" target="_blank" class="pub-link">Link</a>
                                <a href="https://doi.org/10.1145/3736731.3746156" target="_blank" class="pub-link secondary">DOI</a>
                                <button class="pub-link secondary" onclick="showBibtex('bibtex3')">BibTeX</button>
                            </div>
                            <div class="publication-title">R4R: Reproducibility for R</div>
                            <div class="publication-authors">P. Donat-Bouillud, F. Křikava, S. Krynski, J. Vitek</div>
                            <div class="publication-venue">Proceedings of the 3rd ACM Conference on Reproducibility and Replicability, pp. 132–142, 2025</div>
                            <div id="abstract3" class="publication-abstract">
                                <p class="abstract-text">Ensuring reproducibility is a fundamental challenge in computational research. Reproducing results often requires reconstructing complex software environments involving data files, external tools, system libraries, and language-specific packages. While various tools aim to simplify this process, they often rely on user-provided metadata, overlook system dependencies, or produce unnecessarily large environments. We present r4r, a tool that automates the creation of minimal, user-inspectable, self-contained execution environments through dynamic program analysis techniques. r4r captures all runtime dependencies of a data analysis pipeline and produces a Docker image capable of reproducing the original execution. Although designed with first-class support for the R programming language, r4r also includes a generic fallback mechanism applicable to other languages. We evaluate r4r on a collection of R Markdown notebooks from Kaggle and find that it achieves exact reproducibility for 97.5% of deterministic notebooks.</p>
                            </div>
                            <div id="bibtex3" class="bibtex-content" style="display: none;">
                                <pre>@inproceedings{donatbouillud_r4r_2025,
    title = {{R4R: Reproducibility for R}},
    author = {Donat-Bouillud, Pierre and Křikava, Filip and Krynski, Sebastian and Vitek, Jan},
    year = {2025},
    booktitle = {{Proceedings of the 3rd ACM Conference on Reproducibility and Replicability}},
    publisher = {Association for Computing Machinery},
    series = {{ACM REP '25}},
    location = {New York, NY, USA},
    doi = {10.1145/3736731.3746156},
    isbn = {9798400719585},
    pages = {132--142},
    url = {https://doi.org/10.1145/3736731.3746156},
}</pre>
                            </div>
                        </div>
                        
                        <div class="publication-item">
                            <div class="publication-links">
                                <a href="https://drops.dagstuhl.de/entities/document/10.4230/OASIcs.Programming.2025.24" target="_blank" class="pub-link">Link</a>
                                <a href="https://doi.org/10.4230/OASIcs.Programming.2025.24" target="_blank" class="pub-link secondary">DOI</a>
                                <button class="pub-link secondary" onclick="showBibtex('bibtex4')">BibTeX</button>
                            </div>
                            <div class="publication-title">Toward a Typed Intermediate Language for R</div>
                            <div class="publication-authors">M. Laurent, J. Hain, F. Krikava, S. Krynski, J. Vitek</div>
                            <div class="publication-venue">Companion Proceedings of the 9th International Conference on the Art, Science, and Engineering of Programming (Programming 2025), pp. 24:1–24:4, 2025</div>
                            <div id="abstract4" class="publication-abstract">
                                <p class="abstract-text">Compilers for dynamic languages often rely on intermediate representations with explicit type annotations to facilitate writing program transformations. This paper documents the design of a new typed intermediate representation for a just-in-time compiler for the R programming language called FIŘ. Type annotations, in FIŘ, capture properties such as sharing, the potential for effects, and compiler speculations. In this extended abstract, we focus on the sharing properties that may be used to optimize away some copies of values.</p>
                            </div>
                            <div id="bibtex4" class="bibtex-content" style="display: none;">
                                <pre>@inproceedings{laurent_toward_2025,
    title = {{Toward a Typed Intermediate Language for R}},
    author = {Laurent, Mickaël and Hain, Jakob and Krikava, Filip and Krynski, Sebastián and Vitek, Jan},
    year = {2025},
    booktitle = {{Companion Proceedings of the 9th International Conference on the Art, Science, and Engineering of Programming (Programming 2025)}},
    editor = {Edwards, Jonathan and Perera, Roly and Petricek, Tomas},
    publisher = {Schloss Dagstuhl -- Leibniz-Zentrum für Informatik},
    series = {{Open Access Series in Informatics (OASIcs)}},
    location = {Dagstuhl, Germany},
    doi = {10.4230/OASIcs.Programming.2025.24},
    isbn = {978-3-95977-382-9},
    pages = {24:1--24:4},
    url = {https://drops.dagstuhl.de/entities/document/10.4230/OASIcs.Programming.2025.24},
    volume = {134},
}</pre>
                            </div>
                        </div>
                        
                        <h3 class="publication-year-header">2024</h3>
                        <div class="publication-item">
                            <div class="publication-links">
                                <a href="https://doi.org/10.1145/3689751" target="_blank" class="pub-link">Link</a>
                                <a href="https://doi.org/10.1145/3689751" target="_blank" class="pub-link secondary">DOI</a>
                                <button class="pub-link secondary" onclick="showBibtex('bibtex_new3')">BibTeX</button>
                            </div>
                            <div class="publication-title">Gradient: Gradual Compartmentalization via Object Capabilities Tracked in Types</div>
                            <div class="publication-authors">A. Boruch-Gruszecki, A. Ghosn, M. Payer, C. Pit-Claudel</div>
                            <div class="publication-venue">Proceedings of the ACM on Programming Languages, Volume 8, Issue OOPSLA, October 2024, 2024</div>
                            <div id="abstract_new3" class="publication-abstract">
                                <p class="abstract-text">Modern software needs fine-grained compartmentalization, i.e., intra-process isolation. A particularly important reason for it are supply-chain attacks, the need for which is aggravated by modern applications depending on hundreds or even thousands of libraries. Object capabilities are a particularly salient approach to compartmentalization, but they require the entire program to assume a lack of ambient authority. Most of existing code was written under no such assumption; effectively, existing applications need to undergo a rewrite-the-world migration to reap the advantages of ocap. We propose gradual compartmentalization, an approach which allows gradually migrating an application to object capabilities, component by component in arbitrary order, all the while continuously enjoying security guarantees. The approach relies on runtime authority enforcement and tracking the authority of objects the type system. We present Gradient, a proof-of-concept gradual compartmentalization extension to Scala which uses Enclosures and Capture Tracking as its key components. We evaluate our proposal by migrating the standard XML library of Scala to Gradient.</p>
                            </div>
                            <div id="bibtex_new3" class="bibtex-content" style="display: none;">
                                <pre>@article{boruch_gruszecki_gradient_2024,
    title = {{Gradient: Gradual Compartmentalization via Object Capabilities Tracked in Types}},
    author = {Boruch-Gruszecki, Aleksander and Ghosn, Adrien and Payer, Mathias and Pit-Claudel, Clément},
    year = {2024},
    journal = {Proc. ACM Program. Lang.},
    volume = {8},
    number = {OOPSLA},
    doi = {10.1145/3689751},
    url = {https://doi.org/10.1145/3689751},
}</pre>
                            </div>
                        </div>
                        
                        <div class="publication-item">
                            <div class="publication-links">
                                <a href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.13" target="_blank" class="pub-link">Link</a>
                                <a href="https://doi.org/10.4230/LIPIcs.ECOOP.2024.13" target="_blank" class="pub-link secondary">DOI</a>
                                <button class="pub-link secondary" onclick="showBibtex('bibtex_new4')">BibTeX</button>
                            </div>
                            <div class="publication-title">Pure Methods for roDOT</div>
                            <div class="publication-authors">V. Dort, Y. Li, O. Lhoták, P. Parízek</div>
                            <div class="publication-venue">38th European Conference on Object-Oriented Programming (ECOOP 2024), 2024</div>
                            <div id="abstract_new4" class="publication-abstract">
                                <p class="abstract-text">Object-oriented programming languages typically allow mutation of objects, but pure methods are common too. There is great interest in recognizing which methods are pure, because it eases analysis of program behavior and allows modifying the program without changing its behavior. The roDOT calculus is a formal calculus extending DOT with reference mutability. In this paper, we explore purity conditions in roDOT and pose a SEF guarantee, by which the type system guarantees that methods of certain types are side-effect free. We use the idea from ReIm to detect pure methods by argument types. Applying this idea to roDOT required just a few changes to the type system, but necessitated re-working a significant part of the soundness proof. In addition, we state a transformation guarantee, which states that in a roDOT program, calls to SEF methods can be safely reordered without changing the outcome of the program. We proved type soundness of the updated roDOT calculus, using multiple layers of typing judgments. We proved the SEF guarantee by applying the Immutability guarantee, and the transformation guarantee by applying the SEF guarantee within a framework for reasoning about safe transformations of roDOT programs. All proofs are mechanized in Coq.</p>
                            </div>
                            <div id="bibtex_new4" class="bibtex-content" style="display: none;">
                                <pre>@inproceedings{dort_pure_2024,
    title = {{Pure Methods for roDOT}},
    author = {Dort, Vlastimil and Li, Yufeng and Lhoták, Ondřej and Parizek, Pavel},
    year = {2024},
    booktitle = {{38th European Conference on Object-Oriented Programming (ECOOP 2024)}},
    publisher = {Schloss Dagstuhl - Leibniz-Zentrum für Informatik},
    series = {{LIPIcs}},
    doi = {10.4230/LIPICS.ECOOP.2024.13},
    pages = {13:1--13:29},
    url = {https://doi.org/10.4230/LIPIcs.ECOOP.2024.13},
    volume = {313},
}</pre>
                            </div>
                        </div>
                        
                        <div class="publication-item">
                            <div class="publication-links">
                                <a href="https://doi.org/10.48550/arXiv.2402.14625" target="_blank" class="pub-link">Link</a>
                                <a href="https://doi.org/10.48550/arXiv.2402.14625" target="_blank" class="pub-link secondary">DOI</a>
                                <button class="pub-link secondary" onclick="showBibtex('bibtex_new5')">BibTeX</button>
                            </div>
                            <div class="publication-title">Putting the Count Back Into Accountability: An Analysis of Transparency Data About the Sexual Exploitation of Minors</div>
                            <div class="publication-authors">R. Grimm</div>
                            <div class="publication-venue">arXiv preprint, 2024</div>
                            <div id="abstract_new5" class="publication-abstract">
                                <p class="abstract-text">Alarmist and sensationalist statements about the "explosion" of online child sexual exploitation or CSE dominate much of the public discourse about the topic. Based on a new dataset collecting the transparency disclosures for 16 US-based internet platforms and the national clearinghouse collecting legally mandated reports about CSE, this study seeks answers to two research questions: First, what does the data tell us about the growth of online CSE? Second, how reliable and trustworthy is that data? To answer the two questions, this study proceeds in three parts. First, we leverage a critical literature review to synthesize a granular model for CSE reporting. Second, we analyze the growth in CSE reports over the last 25 years and correlate it with the growth of social media user accounts. Third, we use two comparative audits to assess the quality of transparency data. Critical findings include: First, US law increasingly threatens the very population it claims to protect, i.e., children and adolescents. Second, the rapid growth of CSE report over the last decade is linear and largely driven by an equivalent growth in social media user accounts. Third, the Covid-19 pandemic had no statistically relevant impact on report volume. Fourth, while half of surveyed organizations release meaningful and reasonably accurate transparency data, the other half either fail to make disclosures or release data with severe quality issues.</p>
                            </div>
                            <div id="bibtex_new5" class="bibtex-content" style="display: none;">
                                <pre>@misc{grimm2024puttingcountaccountabilityanalysis,
    title = {{Putting the Count Back Into Accountability: An Analysis of Transparency Data About the Sexual Exploitation of Minors}},
    author = {Grimm, Robert},
    year = {2024},
    eprint = {2402.14625},
    archivePrefix = {arXiv},
    primaryClass = {cs.CY},
    doi = {10.48550/arXiv.2402.14625},
    url = {https://arxiv.org/abs/2402.14625},
}</pre>
                            </div>
                        </div>
                        
                        <div class="publication-item">
                            <div class="publication-links">
                                <a href="https://dl.acm.org/doi/10.1145/3656421" target="_blank" class="pub-link">Link</a>
                                <a href="https://doi.org/10.1145/3656421" target="_blank" class="pub-link secondary">DOI</a>
                                <button class="pub-link secondary" onclick="showBibtex('bibtex5')">BibTeX</button>
                            </div>
                            <div class="publication-title">Decidable Subtyping of Existential Types for Julia</div>
                            <div class="publication-authors">J. Belyakova, B. Chung, R. Tate, J. Vitek</div>
                            <div class="publication-venue">Proc. ACM Program. Lang. 8(PLDI), pp. 191:1091–191:1114, 2024</div>
                            <div id="abstract5" class="publication-abstract">
                                <p class="abstract-text">Julia is a modern scientific-computing language that relies on multiple dispatch to implement generic libraries. While the language does not have a static type system, method declarations are decorated with expressive type annotations to determine when they are applicable. To find applicable methods, the implementation uses subtyping at run-time. We show that Julia's subtyping is undecidable, and we propose a restriction on types to recover decidability by stratifying types into method signatures over value types---where the former can freely use bounded existential types but the latter are restricted to use-site variance. A corpus analysis suggests that nearly all Julia programs written in practice already conform to this restriction.</p>
                            </div>
                            <div id="bibtex5" class="bibtex-content" style="display: none;">
                                <pre>@article{belyakova_decidable_2024,
    title = {{Decidable Subtyping of Existential Types for Julia}},
    author = {Belyakova, Julia and Chung, Benjamin and Tate, Ross and Vitek, Jan},
    year = {2024},
    journal = {{Proc. ACM Program. Lang.}},
    number = {PLDI},
    doi = {10.1145/3656421},
    pages = {191:1091--191:1114},
    url = {https://dl.acm.org/doi/10.1145/3656421},
    volume = {8},
}</pre>
                            </div>
                        </div>
                        
                        <div class="publication-item">
                            <div class="publication-links">
                                <a href="https://doi.org/10.1145/3689490.3690404" target="_blank" class="pub-link">Link</a>
                                <a href="https://doi.org/10.1145/3689490.3690404" target="_blank" class="pub-link secondary">DOI</a>
                                <button class="pub-link secondary" onclick="showBibtex('bibtex6')">BibTeX</button>
                            </div>
                            <div class="publication-title">Reducing Feedback Pollution</div>
                            <div class="publication-authors">S. Krynski, M. Štěpánek, F. Říha, F. Křikava, J. Vitek</div>
                            <div class="publication-venue">Proceedings of the 16th ACM SIGPLAN International Workshop on Virtual Machines and Intermediate Languages, pp. 65–74, 2024</div>
                            <div id="abstract6" class="publication-abstract">
                                <p class="abstract-text">Just-in-time compilers enhance the performance of future invocations of a function by generating code tailored to past behavior. To achieve this, compilers use a data structure, often referred to as a feedback vector, to record information about each function's invocations. However, over time, feedback vectors tend to become less precise, leading to lower-quality code – a phenomenon known as feedback vector pollution. This paper examines feedback vector pollution within the context of a compiler for the R language. We provide data, discuss an approach to reduce pollution in practice, and implement a proof-of-concept implementation of this approach. The preliminary results of the implementation indicate ∼30% decrease in polluted compilations and ∼37% decrease in function pollution throughout our corpus.</p>
                            </div>
                            <div id="bibtex6" class="bibtex-content" style="display: none;">
                                <pre>@inproceedings{krynski_reducing_2024,
    title = {{Reducing Feedback Pollution}},
    author = {Krynski, Sebastián and Štěpánek, Michal and Říha, Filip and Křikava, Filip and Vitek, Jan},
    year = {2024},
    booktitle = {{Proceedings of the 16th ACM SIGPLAN International Workshop on Virtual Machines and Intermediate Languages}},
    publisher = {Association for Computing Machinery},
    series = {{VMIL '24}},
    location = {New York, NY, USA},
    doi = {10.1145/3689490.3690404},
    isbn = {979-8-4007-1213-5},
    pages = {65--74},
    url = {https://doi.org/10.1145/3689490.3690404},
}</pre>
                            </div>
                        </div>
                        
                        <div class="publication-item">
                            <div class="publication-links">
                                <a href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.27" target="_blank" class="pub-link">Link</a>
                                <a href="https://doi.org/10.4230/LIPIcs.ECOOP.2024.27" target="_blank" class="pub-link secondary">DOI</a>
                                <button class="pub-link secondary" onclick="showBibtex('bibtex7')">BibTeX</button>
                            </div>
                            <div class="publication-title">The Fault in Our Stars: Designing Reproducible Large-scale Code Analysis Experiments</div>
                            <div class="publication-authors">P. Maj, S. Muroya, K. Siek, L. Di Grazia, J. Vitek</div>
                            <div class="publication-venue">ECOOP 2024, 2024</div>
                            <div id="abstract7" class="publication-abstract">
                                <p class="abstract-text">Large-scale software repositories are a source of insights for software engineering. They offer an unmatched window into the software development process at scale. Their sheer number and size holds the promise of broadly applicable results. At the same time, that very size presents practical challenges for scaling tools and algorithms to millions of projects. A reasonable approach is to limit studies to representative samples of the population of interest. Broadly applicable conclusions can then be obtained by generalizing to the entire population. The contribution of this paper is a standardized experimental design methodology for choosing the inputs of studies working with large-scale repositories. We advocate for a methodology that clearly lays out what the population of interest is, how to sample it, and that fosters reproducibility. Along the way, we discourage researchers from using extrinsic attributes of projects such as stars, that measure some unclear notion of popularity.</p>
                            </div>
                            <div id="bibtex7" class="bibtex-content" style="display: none;">
                                <pre>@inproceedings{maj_fault_2024,
    title = {{The Fault in Our Stars: Designing Reproducible Large-scale Code Analysis Experiments}},
    author = {Maj, Petr and Muroya, Stefanie and Siek, Konrad and Di Grazia, Luca and Vitek, Jan},
    year = {2024},
    booktitle = {{DROPS-IDN/v2/document/10.4230/LIPIcs.ECOOP.2024.27}},
    publisher = {Schloss Dagstuhl -- Leibniz-Zentrum für Informatik},
    doi = {10.4230/LIPIcs.ECOOP.2024.27},
    url = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.27},
    shorttitle = {The Fault in Our Stars},
}</pre>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
    </div>

    <footer>
        <div class="container">
            <div class="row align-items-center">
                <div class="col-md-6">
                    <div class="footer-logos">
                        <div class="footer-logo msmt">
                            <a href="">
                                <img src="images/logo/msmt-logo-no-backgroung.png" alt="MŠMT">
                            </a>
                        </div>
                        <div class="footer-logo charles">
                            <a href="">
                                <img src="images/logo/PR-56-version1-uk_uzitna_eng_barevna (1).png" alt="">
                            </a>
                        </div>
                    </div>
                </div>
                <div class="col-md-6 text-md-end">
                    <p class="mb-0">&copy; 2026 Ch-RiGiD. All rights reserved.</p>
                </div>
            </div>
        </div>
    </footer>

    <button class="back-to-top" onclick="window.scrollTo({top: 0, behavior: 'smooth'})"></button>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.0/js/bootstrap.bundle.min.js"></script>
    <script>
        function showBibtex(id) {
            var element = document.getElementById(id);
            if (element.style.display === "none" || element.style.display === "") {
                element.style.display = "block";
            } else {
                element.style.display = "none";
            }
        }
        
        function toggleAbstract(id) {
            var abstractDiv = document.getElementById(id);
            var abstractText = abstractDiv.querySelector('.abstract-text');
            var toggleBtn = abstractDiv.querySelector('.abstract-toggle');
            
            if (abstractText.classList.contains('abstract-truncated')) {
                abstractText.classList.remove('abstract-truncated');
                abstractText.style.maxHeight = 'none';
                toggleBtn.textContent = 'Show less';
            } else {
                abstractText.classList.add('abstract-truncated');
                var lineHeight = parseFloat(window.getComputedStyle(abstractText).lineHeight);
                abstractText.style.maxHeight = (lineHeight * 2) + 'px';
                toggleBtn.textContent = 'Show more';
            }
        }
        
        // Initialize abstracts on page load
        document.addEventListener('DOMContentLoaded', function() {
            var abstracts = document.querySelectorAll('.publication-abstract .abstract-text');
            abstracts.forEach(function(abstract) {
                var abstractDiv = abstract.closest('.publication-abstract');
                var lineHeight = parseFloat(window.getComputedStyle(abstract).lineHeight);
                var maxHeight = lineHeight * 2; // 2 lines
                
                if (abstract.scrollHeight > maxHeight) {
                    abstract.classList.add('abstract-truncated');
                    abstract.style.maxHeight = maxHeight + 'px';
                    
                    // Add toggle button if it doesn't exist
                    if (!abstractDiv.querySelector('.abstract-toggle')) {
                        var toggleBtn = document.createElement('button');
                        toggleBtn.className = 'abstract-toggle';
                        toggleBtn.textContent = 'Show more';
                        toggleBtn.onclick = function() {
                            toggleAbstract(abstractDiv.id);
                        };
                        abstractDiv.appendChild(toggleBtn);
                    }
                }
            });
        });
    </script>
</body>
</html>